<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Endpoint Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Endpoint Management<br/>
<small>
[<a class="el" href="group___group___u_s_b.html">USB Core - LUFA/Drivers/USB/USB.h</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_r_w.html">Endpoint Data Reading and Writing</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_packet_management.html">Endpoint Packet Management</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga5735655e855a6da7ee2e48084c10d9d6">ENDPOINT_CONTROLEP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gaebe9cfe97e9292e5e8cfba9885bbd901">ENDPOINT_CONTROLEP_DEFAULT_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a>&#160;&#160;&#160;0x07</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gaa3e9e2aca0b4a0841fd2a5b6254c9e98">ENDPOINT_EPDIR_MASK</a>&#160;&#160;&#160;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gaafb7a906223f76d344a8ad05bf066f4c">ENDPOINT_EPSIZE_MASK</a>&#160;&#160;&#160;0x7F</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gad9e1bb9ac6153e39301490b29e77e93a">ENDPOINT_MAX_SIZE</a>(EPIndex)&#160;&#160;&#160;_ENDPOINT_GET_MAXSIZE(EPIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga39206fe8d12fdddec3aadc86f1018c88">ENDPOINT_BANKS_SUPPORTED</a>(EPIndex)&#160;&#160;&#160;_ENDPOINT_GET_BANKS(EPIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a>&#160;&#160;&#160;ENDPOINT_DETAILS_MAXEP</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint</a> (const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga3eb31e520c947003839bfb5e1e4bf95c">Endpoint_GetCurrentEndpoint</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gabada4b78b188e85bbbe5af254e7ecf2a">Endpoint_SelectEndpoint</a> (const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga141c5e4750b197c338df2117e0254415">Endpoint_ResetFIFO</a> (const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gafdce33d2159f2b1a6e98216ef29e9654">Endpoint_EnableEndpoint</a> (void) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga001d4ebf384129efc77d239011ca8fdb">Endpoint_DisableEndpoint</a> (void) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga0258dd64dd4215c59ce9713868f5a387">Endpoint_IsEnabled</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga22dedc9265477d753e932fc805ebb91d">Endpoint_IsConfigured</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga4744236ce0d28f80c69a3225fdeabe81">Endpoint_GetEndpointInterrupts</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gadef5dafdf7515ce080f890640fe5f4ef">Endpoint_HasEndpointInterrupted</a> (const uint8_t EndpointNumber) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gac2051cf461db29c5c73651edbe77638a">Endpoint_ResetDataToggle</a> (void) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gaedaf95aead8b39dcea3ed2fa52e86950">Endpoint_GetEndpointDirection</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gae6b0236ec27226add2815d47e7939056">Endpoint_SetEndpointDirection</a> (const uint8_t DirectionMask) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga9e00020d1fca630c351e3b8139ba67df">Endpoint_ClearStatusStage</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Endpoint Direction Masks</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gab011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a>&#160;&#160;&#160;(0 &lt;&lt; EPDIR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gabe19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>&#160;&#160;&#160;(1 &lt;&lt; EPDIR)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Endpoint Bank Mode Masks</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#gae4bc67200452560b253e3f01acae9373">ENDPOINT_BANK_SINGLE</a>&#160;&#160;&#160;(0 &lt;&lt; EPBK0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management.html#ga417e96e8278a9c41e846fff106ce5791">ENDPOINT_BANK_DOUBLE</a>&#160;&#160;&#160;(1 &lt;&lt; EPBK0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions, macros and enums related to endpoint management when in USB Device mode. This module contains the endpoint management macros, as well as endpoint interrupt and data send/receive functions for various data types. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga417e96e8278a9c41e846fff106ce5791"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_DOUBLE" ref="ga417e96e8278a9c41e846fff106ce5791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_DOUBLE&#160;&#160;&#160;(1 &lt;&lt; EPBK0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have two banks, which requires more USB FIFO memory but results in faster transfers as one USB device (the AVR or the host) can access one bank while the other accesses the second bank. </p>

</div>
</div>
<a class="anchor" id="gae4bc67200452560b253e3f01acae9373"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_SINGLE" ref="gae4bc67200452560b253e3f01acae9373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_SINGLE&#160;&#160;&#160;(0 &lt;&lt; EPBK0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have one single bank, which requires less USB FIFO memory but results in slower transfers as only one USB device (the AVR or the host) can access the endpoint's bank at the one time. </p>

</div>
</div>
<a class="anchor" id="ga39206fe8d12fdddec3aadc86f1018c88"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANKS_SUPPORTED" ref="ga39206fe8d12fdddec3aadc86f1018c88" args="(EPIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANKS_SUPPORTED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EPIndex&#160;)</td>
          <td>&#160;&#160;&#160;_ENDPOINT_GET_BANKS(EPIndex)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the total number of banks supported by the given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EPIndex</td><td>Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5735655e855a6da7ee2e48084c10d9d6"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP" ref="ga5735655e855a6da7ee2e48084c10d9d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint address for the default control endpoint, which always resides in address 0. This is defined for convenience to give more readable code when used with the endpoint macros. </p>

</div>
</div>
<a class="anchor" id="gaebe9cfe97e9292e5e8cfba9885bbd901"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP_DEFAULT_SIZE" ref="gaebe9cfe97e9292e5e8cfba9885bbd901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP_DEFAULT_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default size of the default control endpoint's bank, until altered by the control endpoint bank size value in the device descriptor. Not available if the FIXED_CONTROL_ENDPOINT_SIZE token is defined. </p>

</div>
</div>
<a class="anchor" id="gabe19393ecfcac9ea1ee8c6b3dc87830a"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_IN" ref="gabe19393ecfcac9ea1ee8c6b3dc87830a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_IN&#160;&#160;&#160;(1 &lt;&lt; EPDIR)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint data direction mask for <a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the IN direction - i.e. data flows from device to host. </p>

</div>
</div>
<a class="anchor" id="gab011e2ee1e9f55b60cda3dbc79b95961"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_OUT" ref="gab011e2ee1e9f55b60cda3dbc79b95961" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_OUT&#160;&#160;&#160;(0 &lt;&lt; EPDIR)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint data direction mask for <a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the OUT direction - i.e. data flows from host to device. </p>

</div>
</div>
<a class="anchor" id="gaa3e9e2aca0b4a0841fd2a5b6254c9e98"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPDIR_MASK" ref="gaa3e9e2aca0b4a0841fd2a5b6254c9e98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPDIR_MASK&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint direction mask, for masking against endpoint addresses to retrieve the endpoint's direction for comparing with the ENDPOINT_DESCRIPTOR_DIR_* masks. </p>

</div>
</div>
<a class="anchor" id="ga6ee88e6fd992e2a064923871980b493d"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPNUM_MASK" ref="ga6ee88e6fd992e2a064923871980b493d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPNUM_MASK&#160;&#160;&#160;0x07</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's numerical address in the device. </p>

</div>
</div>
<a class="anchor" id="gaafb7a906223f76d344a8ad05bf066f4c"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPSIZE_MASK" ref="gaafb7a906223f76d344a8ad05bf066f4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPSIZE_MASK&#160;&#160;&#160;0x7F</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's bank size in the device. </p>

</div>
</div>
<a class="anchor" id="gad9e1bb9ac6153e39301490b29e77e93a"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_MAX_SIZE" ref="gad9e1bb9ac6153e39301490b29e77e93a" args="(EPIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EPIndex&#160;)</td>
          <td>&#160;&#160;&#160;_ENDPOINT_GET_MAXSIZE(EPIndex)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum size in bytes of a given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EPIndex</td><td>Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0aaeafaa974fb7095750a771e2adfc73"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_TOTAL_ENDPOINTS" ref="ga0aaeafaa974fb7095750a771e2adfc73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_TOTAL_ENDPOINTS&#160;&#160;&#160;ENDPOINT_DETAILS_MAXEP</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of endpoints (including the default control endpoint at address 0) which may be used in the device. Different USB AVR models support different amounts of endpoints, this value reflects the maximum number of endpoints for the currently selected AVR model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9e00020d1fca630c351e3b8139ba67df"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearStatusStage" ref="ga9e00020d1fca630c351e3b8139ba67df" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Endpoint_ClearStatusStage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the status stage of a control transfer on a CONTROL type endpoint automatically, with respect to the data direction. This is a convenience function which can be used to simplify user control request handling. </p>

</div>
</div>
<a class="anchor" id="ga22272fed65e01ca76a4571f9914b5fe5"></a><!-- doxytag: member="Endpoint.h::Endpoint_ConfigureEndpoint" ref="ga22272fed65e01ca76a4571f9914b5fe5" args="(const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_ConfigureEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"> <em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Banks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the specified endpoint number with the given endpoint type, direction, bank size and banking mode. Once configured, the endpoint may be read from or written to, depending on its direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Number</td><td>Endpoint number to configure. This must be more than 0 and less than <a class="el" href="group___group___endpoint_management.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>Type of endpoint to configure, a EP_TYPE_* mask. Not all endpoint types are available on Low Speed USB devices - refer to the USB 2.0 specification.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Endpoint data direction, either <a class="el" href="group___group___endpoint_management.html#gab011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a> or <a class="el" href="group___group___endpoint_management.html#gabe19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>. All endpoints (except Control type) are unidirectional - data may only be read from or written to the endpoint bank based on its direction, not both.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>Size of the endpoint's bank, where packets are stored before they are transmitted to the USB host, or after they have been received from the USB host (depending on the endpoint's data direction). The bank size must indicate the maximum packet size that the endpoint can handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Banks</td><td>Number of banks to use for the endpoint being configured, an ENDPOINT_BANK_* mask. More banks uses more USB DPRAM, but offers better performance. Isochronous type endpoints <b>must</b> have at least two banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Endpoints <b>must</b> be configured in ascending order, or bank corruption will occur. <br/>
<br/>
</dd>
<dd>
Certain models of USB AVR's endpoints may have different maximum packet sizes based on the endpoint's index - refer to the chosen USB AVR's datasheet to determine the maximum bank size for each endpoint. <br/>
<br/>
</dd>
<dd>
The default control endpoint should not be manually configured by the user application, as it is automatically configured by the library internally. <br/>
<br/>
</dd>
<dd>
This routine will automatically select the specified endpoint upon success. Upon failure, the endpoint which failed to reconfigure correctly will be selected.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the configuration succeeded, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga001d4ebf384129efc77d239011ca8fdb"></a><!-- doxytag: member="Endpoint.h::Endpoint_DisableEndpoint" ref="ga001d4ebf384129efc77d239011ca8fdb" args="(void) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_DisableEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the currently selected endpoint so that data cannot be sent and received through it to and from a host. </p>

</div>
</div>
<a class="anchor" id="gafdce33d2159f2b1a6e98216ef29e9654"></a><!-- doxytag: member="Endpoint.h::Endpoint_EnableEndpoint" ref="gafdce33d2159f2b1a6e98216ef29e9654" args="(void) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_EnableEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the currently selected endpoint so that data can be sent and received through it to and from a host.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Endpoints must first be configured properly via <a class="el" href="group___group___endpoint_management.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3eb31e520c947003839bfb5e1e4bf95c"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetCurrentEndpoint" ref="ga3eb31e520c947003839bfb5e1e4bf95c" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetCurrentEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the endpoint address of the currently selected endpoint. This is typically used to save the currently selected endpoint number so that it can be restored after another endpoint has been manipulated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the currently selected endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedaf95aead8b39dcea3ed2fa52e86950"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetEndpointDirection" ref="gaedaf95aead8b39dcea3ed2fa52e86950" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointDirection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the currently selected endpoint's direction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4744236ce0d28f80c69a3225fdeabe81"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetEndpointInterrupts" ref="ga4744236ce0d28f80c69a3225fdeabe81" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointInterrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their interrupt duration has elapsed. Which endpoints have interrupted can be determined by masking the return value against (1 &lt;&lt; {Endpoint Number}).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mask whose bits indicate which endpoints have interrupted. </dd></dl>

</div>
</div>
<a class="anchor" id="gadef5dafdf7515ce080f890640fe5f4ef"></a><!-- doxytag: member="Endpoint.h::Endpoint_HasEndpointInterrupted" ref="gadef5dafdf7515ce080f890640fe5f4ef" args="(const uint8_t EndpointNumber) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_HasEndpointInterrupted </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>EndpointNumber</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type endpoints).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Index of the endpoint whose interrupt flag should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the specified endpoint has interrupted, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22dedc9265477d753e932fc805ebb91d"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsConfigured" ref="ga22dedc9265477d753e932fc805ebb91d" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsConfigured </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the currently selected endpoint has been configured, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0258dd64dd4215c59ce9713868f5a387"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsEnabled" ref="ga0258dd64dd4215c59ce9713868f5a387" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is enabled, but not necessarily configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean True if the currently selected endpoint is enabled, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2051cf461db29c5c73651edbe77638a"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetDataToggle" ref="gac2051cf461db29c5c73651edbe77638a" args="(void) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetDataToggle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the data toggle of the currently selected endpoint. </p>

</div>
</div>
<a class="anchor" id="ga141c5e4750b197c338df2117e0254415"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetFIFO" ref="ga141c5e4750b197c338df2117e0254415" args="(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetFIFO </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>EndpointNumber</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB controller's In and Out pointers to the bank's contents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Endpoint number whose FIFO buffers are to be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabada4b78b188e85bbbe5af254e7ecf2a"></a><!-- doxytag: member="Endpoint.h::Endpoint_SelectEndpoint" ref="gabada4b78b188e85bbbe5af254e7ecf2a" args="(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_SelectEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>EndpointNumber</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the given endpoint number. If the address from the device descriptors is used, the value should be masked with the <a class="el" href="group___group___endpoint_management.html#ga6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a> constant to extract only the endpoint number (and discarding the endpoint direction bit).</p>
<p>Any endpoint operations which do not require the endpoint number to be indicated will operate on the currently selected endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Endpoint number to select. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6b0236ec27226add2815d47e7939056"></a><!-- doxytag: member="Endpoint.h::Endpoint_SetEndpointDirection" ref="gae6b0236ec27226add2815d47e7939056" args="(const uint8_t DirectionMask) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_SetEndpointDirection </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>DirectionMask</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the direction of the currently selected endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DirectionMask</td><td>New endpoint direction, as a ENDPOINT_DIR_* mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga8422610dc18164a09618d82b9306c365"></a><!-- doxytag: member="Endpoint.h::USB_ControlEndpointSize" ref="ga8422610dc18164a09618d82b9306c365" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="group___group___endpoint_management.html#ga8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global indicating the maximum packet size of the default control endpoint located at address 0 in the device. This value is set to the value indicated in the device descriptor in the user project once the USB interface is initialized into device mode.</p>
<p>If space is an issue, it is possible to fix this to a static value by defining the control endpoint size in the FIXED_CONTROL_ENDPOINT_SIZE token passed to the compiler in the makefile via the -D switch. When a fixed control endpoint size is used, the size is no longer dynamically read from the descriptors at runtime and instead fixed to the given value. When used, it is important that the descriptor control endpoint size value matches the size given as the FIXED_CONTROL_ENDPOINT_SIZE token - it is recommended that the FIXED_CONTROL_ENDPOINT_SIZE token be used in the descriptors to ensure this.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This variable should be treated as read-only in the user application, and never manually changed in value. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
