<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Mass Storage Class Host Mode Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Mass Storage Class Host Mode Driver<br/>
<small>
[<a class="el" href="group___group___u_s_b_class_m_s.html">Mass Storage Class Driver</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass Storage Class Host Mode Configuration and State Structure.  <a href="struct_u_s_b___class_info___m_s___host__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c_s_i___capacity__t.html">SCSI_Capacity_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SCSI Device LUN Capacity Structure.  <a href="struct_s_c_s_i___capacity__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a>&#160;&#160;&#160;0x80</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga54e6647c15f102357187c57aa3635aca">MS_Host_EnumerationFailure_ErrorCodes_t</a> { <br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gga54e6647c15f102357187c57aa3635acaad8196f8e2ffcf357898deb9d07431e31">MS_ENUMERROR_NoError</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gga54e6647c15f102357187c57aa3635acaafbbef39c881abade045797c510908d47">MS_ENUMERROR_InvalidConfigDescriptor</a> =  1, 
<br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gga54e6647c15f102357187c57aa3635acaa9dc0d68669c609c73026f50fbdbd0317">MS_ENUMERROR_NoCompatibleInterfaceFound</a> =  2
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga16dfa07097a5e616ae7facb096c4051a">MS_Host_ConfigurePipes</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, uint16_t ConfigDescriptorSize, void *ConfigDescriptorData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga836c783570793a41d6f540539e610504">MS_Host_ResetMSInterface</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gab50f9eaea2a934c52bc82afe4ca08a92">MS_Host_GetMaxLUN</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, uint8_t *const MaxLUNIndex) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gab4405797e90fb94f95f308de979ec57d">MS_Host_GetInquiryData</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, <a class="el" href="struct_s_c_s_i___inquiry___response__t.html">SCSI_Inquiry_Response_t</a> *const InquiryData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga43038c9348b0d6a594fbc087545b45f2">MS_Host_TestUnitReady</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga384e2033ee8d638c273829170375339f">MS_Host_ReadDeviceCapacity</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, <a class="el" href="struct_s_c_s_i___capacity__t.html">SCSI_Capacity_t</a> *const DeviceCapacity) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga278c491541dfc19d605cf3b1dbe1626f">MS_Host_RequestSense</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, <a class="el" href="struct_s_c_s_i___request___sense___response__t.html">SCSI_Request_Sense_Response_t</a> *const SenseData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga81b8246de5d2206979d427890717450a">MS_Host_PreventAllowMediumRemoval</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, const bool PreventRemoval) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga02990a17fc1d67f2097072cf2b892a71">MS_Host_ReadDeviceBlocks</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BlockBuffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaf543251bbb80918c48ada00b584b06f2">MS_Host_WriteDeviceBlocks</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo, const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, const void *BlockBuffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga723c9c545b5672974c4dcfd664e23b2c">MS_Host_USBTask</a> (<a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const MSInterfaceInfo)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="Sec_Dependencies"></a>
Module Source Dependencies</h2>
<p>The following files must be built with any user project that uses this module:</p>
<ul>
<li>LUFA/Drivers/USB/Class/Host/MassStorage.c <em>(Makefile source module name: LUFA_SRC_USBCLASS)</em></li>
</ul>
<h2><a class="anchor" id="Module"></a>
Description</h2>
<p>Host Mode USB Class driver framework interface, for the Mass Storage USB Class driver. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaba886cc65f248c2cae1d4482166e836c"></a><!-- doxytag: member="MassStorage.h::MS_ERROR_LOGICAL_CMD_FAILED" ref="gaba886cc65f248c2cae1d4482166e836c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MS_ERROR_LOGICAL_CMD_FAILED&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Error code for some Mass Storage Host functions, indicating a logical (and not hardware) error. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga54e6647c15f102357187c57aa3635aca"></a><!-- doxytag: member="MassStorage.h::MS_Host_EnumerationFailure_ErrorCodes_t" ref="ga54e6647c15f102357187c57aa3635aca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga54e6647c15f102357187c57aa3635aca">MS_Host_EnumerationFailure_ErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga54e6647c15f102357187c57aa3635acaad8196f8e2ffcf357898deb9d07431e31"></a><!-- doxytag: member="MS_ENUMERROR_NoError" ref="gga54e6647c15f102357187c57aa3635acaad8196f8e2ffcf357898deb9d07431e31" args="" -->MS_ENUMERROR_NoError</em>&nbsp;</td><td>
<p>Configuration Descriptor was processed successfully. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga54e6647c15f102357187c57aa3635acaafbbef39c881abade045797c510908d47"></a><!-- doxytag: member="MS_ENUMERROR_InvalidConfigDescriptor" ref="gga54e6647c15f102357187c57aa3635acaafbbef39c881abade045797c510908d47" args="" -->MS_ENUMERROR_InvalidConfigDescriptor</em>&nbsp;</td><td>
<p>The device returned an invalid Configuration Descriptor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga54e6647c15f102357187c57aa3635acaa9dc0d68669c609c73026f50fbdbd0317"></a><!-- doxytag: member="MS_ENUMERROR_NoCompatibleInterfaceFound" ref="gga54e6647c15f102357187c57aa3635acaa9dc0d68669c609c73026f50fbdbd0317" args="" -->MS_ENUMERROR_NoCompatibleInterfaceFound</em>&nbsp;</td><td>
<p>A compatible Mass Storage interface was not found in the device's Configuration Descriptor. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga16dfa07097a5e616ae7facb096c4051a"></a><!-- doxytag: member="MassStorage.h::MS_Host_ConfigurePipes" ref="ga16dfa07097a5e616ae7facb096c4051a" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, uint16_t ConfigDescriptorSize, void *ConfigDescriptorData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_ConfigurePipes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"> <em>ConfigDescriptorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ConfigDescriptorData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Host interface configuration routine, to configure a given Mass Storage host interface instance using the Configuration Descriptor read from an attached USB device. This function automatically updates the given Mass Storage Host instance's state values and configures the pipes required to communicate with the interface if it is found within the device. This should be called once after the stack has enumerated the attached device, while the host state machine is in the Addressed state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The pipe index numbers as given in the interface's configuration structure must not overlap with any other interface, or pipe bank corruption will occur. Gaps in the allocated pipe numbers or non-sequential indexes within a single interface is allowed, but no two interfaces of any type have have interleaved pipe indexes.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing an MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigDescriptorSize</td><td>Length of the attached device's Configuration Descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigDescriptorData</td><td>Pointer to a buffer containing the attached device's Configuration Descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#ga54e6647c15f102357187c57aa3635aca">MS_Host_EnumerationFailure_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gab4405797e90fb94f95f308de979ec57d"></a><!-- doxytag: member="MassStorage.h::MS_Host_GetInquiryData" ref="gab4405797e90fb94f95f308de979ec57d" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, SCSI_Inquiry_Response_t *const InquiryData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_GetInquiryData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_s_i___inquiry___response__t.html">SCSI_Inquiry_Response_t</a> *const &#160;</td>
          <td class="paramname"> <em>InquiryData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">InquiryData</td><td>Location where the read inquiry data should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab50f9eaea2a934c52bc82afe4ca08a92"></a><!-- doxytag: member="MassStorage.h::MS_Host_GetMaxLUN" ref="gab50f9eaea2a934c52bc82afe4ca08a92" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, uint8_t *const MaxLUNIndex) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_GetMaxLUN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const &#160;</td>
          <td class="paramname"> <em>MaxLUNIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a GET MAX LUN control request to the attached device, retrieving the index of the highest LUN (Logical UNit, a logical drive) in the device. This value can then be used in the other functions of the Mass Storage Host mode Class driver to address a specific LUN within the device.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some devices do not support this request, and will STALL it when issued. To get around this, on unsupported devices the max LUN index will be reported as zero and no error will be returned if the device STALLs the request.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxLUNIndex</td><td>Pointer to a location where the highest LUN index value should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_control_req.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81b8246de5d2206979d427890717450a"></a><!-- doxytag: member="MassStorage.h::MS_Host_PreventAllowMediumRemoval" ref="ga81b8246de5d2206979d427890717450a" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, const bool PreventRemoval) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_PreventAllowMediumRemoval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> <em>PreventRemoval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PreventRemoval</td><td>Boolean true if the device should be locked from removal, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02990a17fc1d67f2097072cf2b892a71"></a><!-- doxytag: member="MassStorage.h::MS_Host_ReadDeviceBlocks" ref="ga02990a17fc1d67f2097072cf2b892a71" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BlockBuffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_ReadDeviceBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"> <em>BlockAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"> <em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>BlockBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads blocks of data from the attached Mass Storage device's medium.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockAddress</td><td>Starting block address within the device to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blocks</td><td>Total number of blocks to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockSize</td><td>Size in bytes of each block within the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BlockBuffer</td><td>Pointer to where the read data from the device should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
<a class="anchor" id="ga384e2033ee8d638c273829170375339f"></a><!-- doxytag: member="MassStorage.h::MS_Host_ReadDeviceCapacity" ref="ga384e2033ee8d638c273829170375339f" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, SCSI_Capacity_t *const DeviceCapacity) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_ReadDeviceCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_s_i___capacity__t.html">SCSI_Capacity_t</a> *const &#160;</td>
          <td class="paramname"> <em>DeviceCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DeviceCapacity</td><td>Pointer to the location where the capacity information should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
<a class="anchor" id="ga278c491541dfc19d605cf3b1dbe1626f"></a><!-- doxytag: member="MassStorage.h::MS_Host_RequestSense" ref="ga278c491541dfc19d605cf3b1dbe1626f" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, SCSI_Request_Sense_Response_t *const SenseData) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_RequestSense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_s_i___request___sense___response__t.html">SCSI_Request_Sense_Response_t</a> *const &#160;</td>
          <td class="paramname"> <em>SenseData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the device sense data, indicating the current device state and error codes for the previously issued command.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SenseData</td><td>Pointer to the location where the sense information should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
<a class="anchor" id="ga836c783570793a41d6f540539e610504"></a><!-- doxytag: member="MassStorage.h::MS_Host_ResetMSInterface" ref="ga836c783570793a41d6f540539e610504" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_ResetMSInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_control_req.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43038c9348b0d6a594fbc087545b45f2"></a><!-- doxytag: member="MassStorage.h::MS_Host_TestUnitReady" ref="ga43038c9348b0d6a594fbc087545b45f2" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_TestUnitReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
<a class="anchor" id="ga723c9c545b5672974c4dcfd664e23b2c"></a><!-- doxytag: member="MassStorage.h::MS_Host_USBTask" ref="ga723c9c545b5672974c4dcfd664e23b2c" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void MS_Host_USBTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>General management task for a given Mass Storage host class interface, required for the correct operation of the interface. This should be called frequently in the main program loop, before the master USB management task <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing an Mass Storage Class host configuration and state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf543251bbb80918c48ada00b584b06f2"></a><!-- doxytag: member="MassStorage.h::MS_Host_WriteDeviceBlocks" ref="gaf543251bbb80918c48ada00b584b06f2" args="(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, const void *BlockBuffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MS_Host_WriteDeviceBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___m_s___host__t.html">USB_ClassInfo_MS_Host_t</a> *const &#160;</td>
          <td class="paramname"> <em>MSInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"> <em>BlockAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"> <em>Blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"> <em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> <em>BlockBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes blocks of data to the attached Mass Storage device's medium.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MSInterfaceInfo</td><td>Pointer to a structure containing a MS Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>LUN index within the device the command is being issued to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockAddress</td><td>Starting block address within the device to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blocks</td><td>Total number of blocks to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockSize</td><td>Size in bytes of each block within the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockBuffer</td><td>Pointer to where the data to write should be sourced from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_stream_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum or <a class="el" href="group___group___u_s_b_class_mass_storage_host.html#gaba886cc65f248c2cae1d4482166e836c">MS_ERROR_LOGICAL_CMD_FAILED</a> if not ready. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
