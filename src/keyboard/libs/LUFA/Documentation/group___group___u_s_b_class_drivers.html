<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: USB Class Drivers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<h1>USB Class Drivers</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_audio.html">Audio Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c.html">CDC-ACM (Virtual Serial) Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_h_i_d.html">HID Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_m_s.html">Mass Storage Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_m_i_d_i.html">MIDI Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_printer.html">Printer Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_r_n_d_i_s.html">RNDIS (Networking) Class Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_s_i.html">Still Image Class Driver</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Drivers for both host and device mode of the standard USB classes, for rapid application development. Class drivers give a framework which sits on top of the low level library API, allowing for standard USB classes to be implemented in a project with minimal user code. These drivers can be used in conjunction with the library low level APIs to implement interfaces both via the class drivers and via the standard library APIs.</p>
<p>Multiple device mode class drivers can be used within a project, including multiple instances of the same class driver. In this way, USB Hosts and Devices can be made quickly using the internal class drivers so that more time and effort can be put into the end application instead of the USB protocol.</p>
<p>The available class drivers and their modes are listed below.</p>
<table class="doxtable">
<tr>
<th width="100px">USB Class </th><th width="90px">Device Mode </th><th width="90px">Host Mode  </th></tr>
<tr>
<td>Audio </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#EE0000">No  </td></tr>
<tr>
<td>CDC </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>HID </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>MIDI </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>Mass Storage </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>Printer </td><td bgcolor="#EE0000">No </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>RNDIS </td><td bgcolor="#00EE00">Yes </td><td bgcolor="#00EE00">Yes  </td></tr>
<tr>
<td>Still Image </td><td bgcolor="#EE0000">No </td><td bgcolor="#00EE00">Yes  </td></tr>
</table>
<h2><a class="anchor" id="Sec_UsingClassDrivers"></a>
Using the Class Drivers</h2>
<p>To make the Class drivers easy to integrate into a user application, they all implement a standardized design with similarly named/used function, enums, defines and types. The two different modes are implemented slightly differently, and thus will be explained separately. For information on a specific class driver, read the class driver's module documentation.</p>
<h3><a class="anchor" id="SSec_ClassDriverDevice"></a>
Device Mode Class Drivers</h3>
<p>Implementing a Device Mode Class Driver in a user application requires a number of steps to be followed. Firstly, the module configuration and state structure must be added to the project source. These structures are named in a similar manner between classes, that of <em>USB_ClassInfo_<b>{Class Name}</b>_Device_t</em>, and are used to hold the complete state and configuration for each class instance. Multiple class instances is where the power of the class drivers lie; multiple interfaces of the same class simply require more instances of the Class Driver's ClassInfo structure.</p>
<p>Inside the ClassInfo structure lies two sections, a <em>Config</em> section, and a <em>State</em> section. The Config section contains the instance's configuration parameters, and <b>must have all fields set by the user application</b> before the class driver is used. Each Device mode Class driver typically contains a set of configuration parameters for the endpoint size/number of the associated logical USB interface, plus any class-specific configuration parameters.</p>
<p>The <em>State</em> section of the ClassInfo structures are designed to be controlled by the Class Drivers only for maintaining the Class Driver instance's state, and should not normally be set by the user application.</p>
<p>The following is an example of a properly initialized instance of the Audio Class Driver structure:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="struct_u_s_b___class_info___audio___device__t.html" title="Audio Class Device Mode Configuration and State Structure.">USB_ClassInfo_Audio_Device_t</a> My_Audio_Interface =
  {
      .<a class="code" href="struct_u_s_b___class_info___audio___device__t.html#a942e8b6f71d58658637f8af19a4a1b81">Config</a> =
          {
              .<a class="code" href="struct_u_s_b___class_info___audio___device__t.html#a6b47e406fae732348c84de632a40a51a">StreamingInterfaceNumber</a> = 1,

              .DataINEndpointNumber     = 1,
              .DataINEndpointSize       = 256,
          },
  };
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The class driver's configuration parameters should match those used in the device's descriptors that are sent to the host.</dd></dl>
<p>To initialize the Class driver instance, the driver's <em><b>{Class Name}</b>_Device_ConfigureEndpoints()</em> function should be called in response to the <a class="el" href="group___group___events.html#ga953a275884b9e33629ff6323fca05252">EVENT_USB_Device_ConfigurationChanged()</a> event. This function will return a boolean value if the driver successfully initialized the instance. Like all the class driver functions, this function takes in the address of the specific instance you wish to initialize - in this manner, multiple separate instances of the same class type can be initialized like thus:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> <a class="code" href="group___group___events.html#ga953a275884b9e33629ff6323fca05252">EVENT_USB_Device_ConfigurationChanged</a>(<span class="keywordtype">void</span>)
  {
    <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_READY);

    <span class="keywordflow">if</span> (!(<a class="code" href="group___group___u_s_b_class_audio_device.html#ga4e46328089c4efd15e8ce25f03e1aa8f">Audio_Device_ConfigureEndpoints</a>(&amp;My_Audio_Interface)))
      <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_ERROR);
  }
</pre></div><p>Once initialized, it is important to maintain the class driver's state by repeatedly calling the Class Driver's <em><b>{Class Name}</b>_Device_USBTask()</em> function in the main program loop. The exact implementation of this function varies between class drivers, and can be used for any internal class driver purpose to maintain each instance. Again, this function uses the address of the instance to operate on, and thus needs to be called for each separate instance, just like the main USB maintenance routine <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a>:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
  {
      SetupHardware();

      <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_NOTREADY);

      <span class="keywordflow">for</span> (;;)
      {
          Create_And_Process_Samples();

          <a class="code" href="group___group___u_s_b_class_audio_device.html#gab42344655b6c43ee596d486bda50bac2">Audio_Device_USBTask</a>(&amp;My_Audio_Interface);
          <a class="code" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask</a>();
      }
  }
</pre></div><p>The final standardized Device Class Driver function is the Control Request handler function <em><b>{Class Name}</b>_Device_ProcessControlRequest()</em>, which should be called when the <a class="el" href="group___group___events.html#ga3f4ce439a74a152e3c8ffda5c7dd201a">EVENT_USB_Device_ControlRequest()</a> event fires. This function should also be called for each class driver instance, using the address of the instance to operate on as the function's parameter. The request handler will abort if it is determined that the current request is not targeted at the given class driver instance, thus these methods can safely be called one-after-another in the event handler with no form of error checking:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> <a class="code" href="group___group___events.html#ga3f4ce439a74a152e3c8ffda5c7dd201a">EVENT_USB_Device_ControlRequest</a>(<span class="keywordtype">void</span>)
  {
      <a class="code" href="group___group___u_s_b_class_audio_device.html#ga8ba3a3d6ccef00636745f47c170b20c7">Audio_Device_ProcessControlRequest</a>(&amp;My_Audio_Interface);
  }
</pre></div><p>Each class driver may also define a set of callback functions (which are prefixed by "CALLBACK_" in the function's name) which <b>must</b> also be added to the user application - refer to each individual class driver's documentation for mandatory callbacks. In addition, each class driver may also define a set of events (identifiable by their prefix of "EVENT_" in the function's name), which the user application <b>may</b> choose to implement, or ignore if not needed.</p>
<p>The individual Device Mode Class Driver documentation contains more information on the non-standardized, class-specific functions which the user application can then use on the driver instances, such as data read and write routines. See each driver's individual documentation for more information on the class-specific functions.</p>
<h3><a class="anchor" id="SSec_ClassDriverHost"></a>
Host Mode Class Drivers</h3>
<p>Implementing a Host Mode Class Driver in a user application requires a number of steps to be followed. Firstly, the module configuration and state structure must be added to the project source. These structures are named in a similar manner between classes, that of <em>USB_ClassInfo_<b>{Class Name}</b>_Host_t</em>, and are used to hold the complete state and configuration for each class instance. Multiple class instances is where the power of the class drivers lie; multiple interfaces of the same class simply require more instances of the Class Driver's ClassInfo structure.</p>
<p>Inside the ClassInfo structure lies two sections, a <em>Config</em> section, and a <em>State</em> section. The Config section contains the instance's configuration parameters, and <b>must have all fields set by the user application</b> before the class driver is used. Each Device mode Class driver typically contains a set of configuration parameters for the endpoint size/number of the associated logical USB interface, plus any class-specific configuration parameters.</p>
<p>The <em>State</em> section of the ClassInfo structures are designed to be controlled by the Class Drivers only for maintaining the Class Driver instance's state, and should not normally be set by the user application.</p>
<p>The following is an example of a properly initialized instance of the MIDI Class Driver structure:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="struct_u_s_b___class_info___m_i_d_i___host__t.html" title="MIDI Class Host Mode Configuration and State Structure.">USB_ClassInfo_MIDI_Host_t</a> My_MIDI_Interface =
  {
      .<a class="code" href="struct_u_s_b___class_info___m_i_d_i___host__t.html#a9c396418a976f01515c6d19258de1661">Config</a> =
          {
              .<a class="code" href="struct_u_s_b___class_info___m_i_d_i___host__t.html#a58c45c119c9f076c4052a770f5d4f88e">DataINPipeNumber</a>       = 1,
              .DataINPipeDoubleBank   = <span class="keyword">false</span>,

              .DataOUTPipeNumber      = 2,
              .DataOUTPipeDoubleBank  = <span class="keyword">false</span>,
          },
  };
</pre></div><p>To initialize the Class driver instance, the driver's <em><b>{Class Name}</b>_Host_ConfigurePipes()</em> function should be called in response to the host state machine entering the <a class="el" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917">HOST_STATE_Addressed</a> state. This function will return an error code from the class driver's <em><b>{Class Name}</b>_EnumerationFailure_ErrorCodes_t</em> enum to indicate if the driver successfully initialized the instance and bound it to an interface in the attached device. Like all the class driver functions, this function takes in the address of the specific instance you wish to initialize - in this manner, multiple separate instances of the same class type can be initialized. A fragment of a Class Driver based Host mode application may look like the following:</p>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">switch</span> (<a class="code" href="group___group___host.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a>)
      {
          <span class="keywordflow">case</span> <a class="code" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917">HOST_STATE_Addressed</a>:
              <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_ENUMERATING);

              uint16_t ConfigDescriptorSize;
              uint8_t  ConfigDescriptorData[512];

              <span class="keywordflow">if</span> (<a class="code" href="group___group___config_descriptor_parser.html#gacb936f8021d9ec7f59b5e8dbea6314c4">USB_Host_GetDeviceConfigDescriptor</a>(1, &amp;ConfigDescriptorSize, ConfigDescriptorData,
                                                     <span class="keyword">sizeof</span>(ConfigDescriptorData)) != <a class="code" href="group___group___config_descriptor_parser.html#gga260aca2e8a4697e42cd0395eebfd2dbcaaf665162b045f7edb4c44b4678a9e2eb">HOST_GETCONFIG_Successful</a>)
              {
                  <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_ERROR);
                  <a class="code" href="group___group___host.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a> = <a class="code" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652af3f3f87924f879ce2395033b9affd999">HOST_STATE_WaitForDeviceRemoval</a>;
                  <span class="keywordflow">break</span>;
              }

              <span class="keywordflow">if</span> (<a class="code" href="group___group___u_s_b_class_m_i_d_i_host.html#ga7ccede0ff72b24e29509924fd1058a7d">MIDI_Host_ConfigurePipes</a>(&amp;My_MIDI_Interface,
                                           ConfigDescriptorSize, ConfigDescriptorData) != <a class="code" href="group___group___u_s_b_class_m_i_d_i_host.html#ggaebedf57a87da61977a474a8fb3313a96a63a841bbf423179931957c0e3657d661">MIDI_ENUMERROR_NoError</a>)
              {
                  <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_ERROR);
                  <a class="code" href="group___group___host.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a> = <a class="code" href="group___group___host.html#ggaa30175c751f951c44bf24fc901480652af3f3f87924f879ce2395033b9affd999">HOST_STATE_WaitForDeviceRemoval</a>;
                  <span class="keywordflow">break</span>;
              }

              <span class="comment">// Other state handler code here</span>
</pre></div><p>Note that the function also required the device's configuration descriptor so that it can determine which interface in the device to bind to - this can be retrieved as shown in the above fragment using the <a class="el" href="group___group___config_descriptor_parser.html#gacb936f8021d9ec7f59b5e8dbea6314c4">USB_Host_GetDeviceConfigDescriptor()</a> function. If the device does not implement the interface the class driver is looking for, if all the matching interfaces are already bound to class driver instances or if an error occurs while binding to a device interface (for example, a device endpoint bank larger that the maximum supported bank size is used) the configuration will fail.</p>
<p>Once initialized, it is important to maintain the class driver's state by repeatedly calling the Class Driver's <em><b>{Class Name}</b>_Host_USBTask()</em> function in the main program loop. The exact implementation of this function varies between class drivers, and can be used for any internal class driver purpose to maintain each instance. Again, this function uses the address of the instance to operate on, and thus needs to be called for each separate instance, just like the main USB maintenance routine <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a>:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
  {
      SetupHardware();

      <a class="code" href="group___group___l_e_ds.html#ga9016c1865a92def355743599b7649ca5">LEDs_SetAllLEDs</a>(LEDMASK_USB_NOTREADY);

      <span class="keywordflow">for</span> (;;)
      {
          <span class="keywordflow">switch</span> (<a class="code" href="group___group___host.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a>)
          {
             <span class="comment">// Host state machine handling here</span>
          }

          <a class="code" href="group___group___u_s_b_class_m_i_d_i_host.html#gaef9a746f4d24abdeb97aa2bfe3efa16d">MIDI_Host_USBTask</a>(&amp;My_Audio_Interface);
          <a class="code" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask</a>();
      }
  }
</pre></div><p>Each class driver may also define a set of callback functions (which are prefixed by "CALLBACK_" in the function's name) which <b>must</b> also be added to the user application - refer to each individual class driver's documentation for mandatory callbacks. In addition, each class driver may also define a set of events (identifiable by their prefix of "EVENT_" in the function's name), which the user application <b>may</b> choose to implement, or ignore if not needed.</p>
<p>The individual Host Mode Class Driver documentation contains more information on the non-standardized, class-specific functions which the user application can then use on the driver instances, such as data read and write routines. See each driver's individual documentation for more information on the class-specific functions. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
